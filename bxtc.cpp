/*
   This file is part of bxtc.
   Copyright Â© CLEARSY 2023
   bxtc is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <list>
#include <map>
#include <set>
#include <sstream>
#include <string>
#include <utility>

using std::cerr;

using std::map;
using std::make_pair;
using std::pair;

#include "tinyxml.h"

static bool tc(TiXmlElement* root);
static bool is_pow_of(int, int);
static bool is_prod_of(int, int, int);
static bool is_pow_of_prod_of(int, int, int);
static bool is_pow_of_pow_of_prod_of(int, int, int);
static bool is_pow(int);
static bool is_pow(TiXmlElement*);
static bool is_prod(int);
static bool is_prod(TiXmlElement*);
static bool is_bool(int);
static bool is_integer(int);
static bool is_real(int);
static bool is_float(int);
static bool are_equal(TiXmlElement* elem1, TiXmlElement* elem2);

static int id_bool = -1;
static int id_integer = -1;
static int id_real = -1;
static int id_float = -1;
static map<int, bool> powerset; // caches test if type is a POW
static map<int, int> powerset_of;  // caches test if second is POW(first)
static map<int, bool> product; // caches test if type is a *
static map<pair<int, int>, int> product_of;  // caches test if second is first.first*first.second
static map<int, TiXmlElement*> typeinfos;

void help()
{
    fprintf(stderr,
            "bxtc is a utility to type check XML files generated by Atelier B.\n"
            "\t(c) 2019-23, Clearsy Systems Engineering\n"
            "Usage:\tbxtc file\n");
}

int main(int argc, char * argv[])
{
    char* filename;

    if (argc != 2) {
        help();
        return EXIT_FAILURE;
    }
    filename = argv[1];
    TiXmlDocument doc(filename);
    if(!doc.LoadFile()) {
        return EXIT_FAILURE;
    }

    bool result = true;
    TiXmlElement* root = doc.FirstChildElement();
    TiXmlElement* tie = root->FirstChildElement("TypeInfos");
    if (tie == nullptr) {
        cerr << "Missing TypeInfos element.\n";
        result = false;
    }
    else {
        for(TiXmlElement* te = tie->FirstChildElement();
            te != NULL;
            te = te->NextSiblingElement()) {
            if(strcmp(te->Value(), "Type") == 0) {
                int id;
                int status = te->QueryIntAttribute("id", &id);
                switch(status) {
                case TIXML_NO_ATTRIBUTE:
                    cerr << te->Row() << "," << te->Column() << ":"
                         << "Missing id attribute for Type element.\n";
                    result = false;
                    break;
                case TIXML_WRONG_TYPE:
                    cerr << te->Row() << "," << te->Column() << ":"
                         << "Erroneous id attribute for Type element.\n";
                    result = false;
                    break;
                default:
                    if(typeinfos.find(id) != typeinfos.end()) {
                        cerr << te->Row() << "," << te->Column() << ":"
                             << "Duplicate type id " << id << ".\n";
                    }
                    else {
                        typeinfos.emplace(make_pair(id, te->FirstChildElement()));
                    }
                    break;
                }
            }
            else {
                cerr << "Erroneous child element for TypeInfos element.\n";
                result = false;
                break;
            }
        }
    }
    result &= tc(root);
    return result ? EXIT_SUCCESS : EXIT_FAILURE;
}

bool tc(TiXmlElement* elem) {
    if(strcmp(elem->Value(), "TypeInfos") == 0)
        return true;
    bool result = true;
    /* Checks existence of the typref attribute + check sub-terms */
    if(strcmp(elem->Value(), "Binary_Exp") == 0 ||
       strcmp(elem->Value(), "Boolean_Exp") == 0 ||
       strcmp(elem->Value(), "Boolean_Literal") == 0 ||
       strcmp(elem->Value(), "EmptySeq") == 0 ||
       strcmp(elem->Value(), "EmptySet") == 0 ||
       strcmp(elem->Value(), "Id") == 0 ||
       strcmp(elem->Value(), "Integer_Literal") == 0 ||
       strcmp(elem->Value(), "Nary_Exp") == 0 ||
       strcmp(elem->Value(), "Quantified_Exp") == 0 ||
       strcmp(elem->Value(), "Quantified_Set") == 0 ||
       strcmp(elem->Value(), "Real_Literal") == 0 ||
       strcmp(elem->Value(), "Record") == 0 ||
       strcmp(elem->Value(), "Record_Field_Access") == 0 ||
       strcmp(elem->Value(), "STRING_Literal") == 0 ||
       strcmp(elem->Value(), "Struct") == 0 ||
       strcmp(elem->Value(), "Ternary_Exp") == 0 ||
       strcmp(elem->Value(), "Unary_Exp") == 0 ||
       strcmp(elem->Value(), "Valuation") == 0
       ) {
        unsigned attr;
        int status;
        status = elem->QueryUnsignedAttribute("typref", &attr);
        switch(status) {
        case TIXML_NO_ATTRIBUTE:
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Missing attribute typref for "
                 << elem->Value()
                 << " element.\n";
            result = false;
            break;
        case TIXML_WRONG_TYPE:
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Erroneous attribute typref for "
                 << elem->Value()
                 << " element.\n";
            result = false;
            break;
        default:
            break;
        }
    }
    else {
        if(elem->Attribute("typref") != nullptr) {
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Unexpected attribute typref for "
                 << elem->Value()
                 << "element.\n";
        }
    }
    if (strcmp(elem->Value(), "Operation_Call") == 0) {
        for(TiXmlElement* child = elem->FirstChildElement();
            child != NULL;
            child = child->NextSiblingElement()) {
            if(strcmp(child->Value(), "Name") == 0)
                continue;
            result &= tc(child);
        }
    }
    else {
        for(TiXmlElement* child = elem->FirstChildElement();
            child != NULL;
            child = child->NextSiblingElement()) {
            result &= tc(child);
        }
    }

    /* Specific type checks */
    if(strcmp(elem->Value(), "Binary_Exp") == 0) {
        int qthis = TIXML_NO_ATTRIBUTE;
        int qleft = TIXML_NO_ATTRIBUTE;
        int qright = TIXML_NO_ATTRIBUTE;
        unsigned tthis;
        unsigned tleft;
        unsigned tright;
        qthis = elem->QueryUnsignedAttribute("typref", &tthis);
        bool left = false;
        for(TiXmlElement* child = elem->FirstChildElement();
            child != NULL;
            child = child->NextSiblingElement()) {
            if(strcmp(child->Value(), "Attr") == 0)
                continue;
            if(!left) {
                qleft = child->QueryUnsignedAttribute("typref", &tleft);
                left = true;
            } else {
                qright = child->QueryUnsignedAttribute("typref", &tright);
            }
        }
        if(qthis == TIXML_SUCCESS &&
           qleft == TIXML_SUCCESS && qright == TIXML_SUCCESS) {
            const char* op = elem->Attribute("op");
            if(strcmp(op, "*s") == 0) {
                if(!is_pow(tleft)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Left argument of product is not a set type.\n";
                    result = false;
                }
                if(!is_pow(tright)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Right argument of product is not a set type.\n";
                    result = false;
                }
                if(!is_pow(tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Cartesian product is not a set type.\n";
                    result = false;
                }
                if(!is_pow_of_prod_of(tleft, tright, tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Error in product type.\n";
                    result = false;
                }
            }
            else if(strcmp(op, "+i") == 0 || strcmp(op, "-i") == 0 ||
                    strcmp(op, "*i") == 0 || strcmp(op, "**i") == 0 ||
                    strcmp(op, "/i") == 0 || strcmp(op, "mod") == 0) {
                if(!is_integer(tleft)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Left argument of " << op << " is not an INTEGER.\n";
                    result = false;
                }
                if(!is_integer(tright)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Right argument of " << op << " is not an INTEGER.\n";
                    result = false;
                }
                if(!is_integer(tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type of" << op << " expression is not INTEGER.\n";
                    result = false;
                }
            }
            else if(strcmp(op, "+r") == 0 || strcmp(op, "-r") == 0 ||
                    strcmp(op, "*r") == 0 || strcmp(op, "/r") == 0) {
                if(!is_real(tleft)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Left argument of " << op << " is not a REAL.\n";
                    result = false;
                }
                if(!is_real(tright)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Right argument of " << op << " is not a REAL.\n";
                    result = false;
                }
                if(!is_real(tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type of" << op << " expression is not a REAL.\n";
                    result = false;
                }
            }
            else if(strcmp(op, "|->") == 0 || strcmp(op, ",") == 0) {
                if(!is_prod_of(tleft, tright, tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type error for pair expression.\n";
                    result = false;
                }
            }
            else if(strcmp(op, "\\/") == 0 || strcmp(op, "/\\") == 0
                    || strcmp(op, "-s") == 0) {
                if(!is_pow(tleft)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Left argument of " << op
                         << " is not a set type.\n";
                    result = false;
                }
                if(!is_pow(tright)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Right argument of " << op
                         << "is not a set type.\n";
                    result = false;
                }
                if(!is_pow(tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Expression is not a set type.\n";
                    result = false;
                }
                if(tleft != tright) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type arguments of " << op
                         << " do not match.\n";
                }
                if(tleft != tthis || tright != tthis) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type argument of " << op
                         << " do not match that of expression.\n";
                }
            }
            else if(strcmp(op, "<->") == 0) {
                if(!is_pow(tleft)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Left argument of " << op
                         << " is not a set type.\n";
                    result = false;
                }
                if(!is_pow(tright)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Right argument of " << op
                         << "is not a set type.\n";
                    result = false;
                }
                if(!is_pow(tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Expression is not a set type.\n";
                    result = false;
                }
                if(!is_pow_of_pow_of_prod_of(tleft, tright, tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type mismatch in " << op << " expression.\n";
                }
            }
        }
        else {
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Missing type in comparison.\n";
        }
    } else if(strcmp(elem->Value(), "Boolean_Exp") == 0 ||
              strcmp(elem->Value(), "Boolean_Literal") == 0) {
        int q = TIXML_NO_ATTRIBUTE;
        int t;
        q = elem->QueryIntAttribute("typref", &t);
        if(q == TIXML_SUCCESS) {
            if(!is_bool(t)) {
                cerr << elem->Row() << "," << elem->Column() << ":"
                     << "Wrong type in Boolean expression.\n";
                result = false;
            }
        }
        else {
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Missing type in Boolean expression.\n";
        }
    } else if(strcmp(elem->Value(), "EmptySet") == 0) {
        int q = TIXML_NO_ATTRIBUTE;
        int t;
        q = elem->QueryIntAttribute("typref", &t);
        if(q == TIXML_SUCCESS) {
            if(!is_pow(t)) {
                cerr << elem->Row() << "," << elem->Column() << ":"
                     << "Wrong type for empty set.\n";
                result = false;
            }
        }
        else {
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Missing type for empty set.\n";
        }
    } else if(strcmp(elem->Value(), "Exp_Comparison") == 0) {
        int qleft = TIXML_NO_ATTRIBUTE;
        int qright = TIXML_NO_ATTRIBUTE;
        unsigned tleft;
        unsigned tright;
        bool left = false;
        for(TiXmlElement* child = elem->FirstChildElement();
            child != NULL;
            child = child->NextSiblingElement()) {
            if(strcmp(child->Value(), "Attr") == 0)
                continue;
            if(!left) {
                qleft = child->QueryUnsignedAttribute("typref", &tleft);
                left = true;
            } else {
                qright = child->QueryUnsignedAttribute("typref", &tright);
            }
        }
        if(qleft == TIXML_SUCCESS && qright == TIXML_SUCCESS) {
            const char* op = elem->Attribute("op");
            if(strcmp(op, "<:") == 0 || strcmp(op, "/<:") == 0 ||
               strcmp(op, "<<:") == 0 ||strcmp(op, "/<<:") == 0 ||
               strcmp(op, "=") == 0 || strcmp(op, "/=") == 0 ||
               strcmp(op, ">=") == 0 || strcmp(op, ">") == 0 ||
               strcmp(op, "<") == 0 || strcmp(op, "<=") == 0 ||
               strcmp(op, ">=i") == 0 || strcmp(op, ">i") == 0 ||
               strcmp(op, "<i") == 0 || strcmp(op, "<=i") == 0 ||
               strcmp(op, ">=r") == 0 || strcmp(op, ">r") == 0 ||
               strcmp(op, "<r") == 0 || strcmp(op, "<=r") == 0 ||
               strcmp(op, ">=f") == 0 || strcmp(op, ">f") == 0 ||
               strcmp(op, "<f") == 0 || strcmp(op, "<=f") == 0) {
                /*
                   @req ITYPE_1-2
                   @req ITYPE_1-3
                 */
                if(tleft != tright) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type mismatch in comparison.\n";
                }
                if((strcmp(op, "<:") == 0 || strcmp(op, "/<:") == 0 ||
                    strcmp(op, "<<:") == 0 ||strcmp(op, "/<<:") == 0) &&
                   !is_pow(tleft)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Expected POW type.\n";
                }
                else if((strcmp(op, ">=i") == 0 || strcmp(op, ">i") == 0 ||
                         strcmp(op, "<i") == 0 || strcmp(op, "<=i") == 0)
                        && !is_integer(tleft)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Expected INTEGER type.\n";
                }
                else if((strcmp(op, ">=r") == 0 || strcmp(op, ">r") == 0 ||
                         strcmp(op, "<r") == 0 || strcmp(op, "<=r") == 0)
                        && !is_real(tleft))  {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Expected REAL type.\n";
                }
                else if((strcmp(op, ">=f") == 0 || strcmp(op, ">f") == 0 ||
                         strcmp(op, "<f") == 0 || strcmp(op, "<=f") == 0)
                        && !is_float(tleft)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Expected FLOAT type.\n";
                }
            }
            else if (strcmp(op, ":") == 0 || strcmp(op, "/:") == 0) {
                /* @req ITYPE_1-1 */
                if(!is_pow_of(tleft, tright)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Typing error.\n";
                }
            }
        } else {
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Missing type in comparison.\n";
        }
    }
    else if (strcmp(elem->Value(), "Nary_Exp") == 0) {
        int qthis = TIXML_NO_ATTRIBUTE;
        int tthis;
        qthis = elem->QueryIntAttribute("typref", &tthis);
        if(qthis == TIXML_SUCCESS) {
            const char* op = elem->Attribute("op");
            if(strcmp(op, "{") == 0) {
                if(!is_pow(tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type of set extension is not a set.\n";
                    result = false;
                }
                else {
                    for(TiXmlElement* child = elem->FirstChildElement();
                        child != NULL;
                        child = child->NextSiblingElement()) {
                        if(strcmp(child->Value(), "Attr") == 0)
                            continue;
                        int targ;
                        int qarg = child->QueryIntAttribute("typref", &targ);
                        if(qarg == TIXML_SUCCESS) {
                            if(!is_pow_of(targ, tthis)) {
                                cerr << elem->Row() << "," << elem->Column() << ":"
                                     << "Type of " << op << " expression "
                                     << "is not the set of its argument type.\n";
                                result = false;
                            }
                        }
                        else {
                            cerr << elem->Row() << "," << elem->Column() << ":"
                                 << "Missing type for element in set extension.\n";
                            result = false;
                        }
                    }
                }
            }
            else if(strcmp(op, "[") == 0) {
            }
            else {
            }
        } else {
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Missing type in set extension.\n";
            result = false;
        }
    }
    else if (strcmp(elem->Value(), "Unary_Exp") == 0) {
        int qthis = TIXML_NO_ATTRIBUTE;
        int qarg = TIXML_NO_ATTRIBUTE;
        int tthis;
        int targ;
        qthis = elem->QueryIntAttribute("typref", &tthis);
        for(TiXmlElement* child = elem->FirstChildElement();
            child != NULL;
            child = child->NextSiblingElement()) {
            if(strcmp(child->Value(), "Attr") == 0)
                continue;
            qarg = child->QueryIntAttribute("typref", &targ);
        }
        if(qthis == TIXML_SUCCESS && qarg == TIXML_SUCCESS) {
            const char* op = elem->Attribute("op");
            if(strcmp(op, "POW") == 0 || strcmp(op, "POW1") == 0 ||
               strcmp(op, "FIN") == 0 || strcmp(op, "FIN1") == 0) {
                if(!is_pow(targ)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type of argument is not a set for "
                         << op << " expression.\n";
                }
                if(!is_pow_of(targ, tthis)) {
                    cerr << elem->Row() << "," << elem->Column() << ":"
                         << "Type of " << op << " expression "
                         << "is not the set of its argument type.\n";
                }
            }
        } else if(qthis != TIXML_SUCCESS) {
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Missing type in unary expression.\n";
            result = false;
        } else {
            cerr << elem->Row() << "," << elem->Column() << ":"
                 << "Missing type for unary expression argument.\n";
            result = false;
        }
    }

    return result;
}

// tests if t is a powerset
static bool is_pow(int t) {
    map<int, bool>::iterator it = powerset.find(t);
    if(it == powerset.end()) {
        map<int, TiXmlElement*>::iterator it2 = typeinfos.find(t);
        if(it2 == typeinfos.end()) {
            cerr << "No type definition for typref " << t << ".\n";
            return false;
        }
        else {
            TiXmlElement* type = it2->second;
            bool result;
            result = type != nullptr &&
                strcmp(type->Value(), "Unary_Exp") == 0 &&
                strcmp(type->Attribute("op"), "POW") == 0;
            powerset.emplace(make_pair(t, result));
            return result;
        }
    }
    else {
        return it->second;
    }
}

static bool is_pow(TiXmlElement* e) {
    return
        e != nullptr &&
        strcmp(e->Value(), "Unary_Exp") == 0 &&
        strcmp(e->Attribute("op"), "POW") == 0;
}

// tests if t is a powerset
static bool is_prod(int t) {
    map<int, bool>::iterator it = product.find(t);
    if(it == product.end()) {
        map<int, TiXmlElement*>::iterator it2 = typeinfos.find(t);
        if(it2 == typeinfos.end()) {
            cerr << "No type definition for typref " << t << ".\n";
            return false;
        }
        else {
            TiXmlElement* type = it2->second;
            bool result;
            result = is_prod(type);
            product.emplace(make_pair(t, result));
            return result;
        }
    }
    else {
        return it->second;
    }
}

static bool is_prod(TiXmlElement* e) {
    return
        e != nullptr &&
        strcmp(e->Value(), "Binary_Exp") == 0 &&
        strcmp(e->Attribute("op"), "*") == 0;
}

static bool get_type_elem(int t, TiXmlElement*& elem) {
    map<int, TiXmlElement*>::iterator it = typeinfos.find(t);
    if(it == typeinfos.end()) {
        cerr << "No type definition for typref " << t << ".\n";
        return false;
    }
    elem = it->second;
    return true;
}

// tests if t is a predefined type
static bool is_predefined(int t, int& id, const char* name) {
    if(id != - 1) {
        return t == id;
    }
    TiXmlElement* elem;
    if(!get_type_elem(t, elem))
        return false;
    if(elem != nullptr &&
       strcmp(elem->Value(), "Id") == 0 &&
       strcmp(elem->Attribute("value"), name) == 0) {
        id = t;
        return true;
    }
    return false;
}

// tests if t is BOOL
static bool is_bool(int t) {
    return is_predefined(t, id_bool, "BOOL");
}

// tests if t is INTEGER
static bool is_integer(int t) {
    return is_predefined(t, id_integer, "INTEGER");
}

// tests if t is REAL
static bool is_real(int t) {
    return is_predefined(t, id_real, "REAL");
}

// tests if t is FLOAT
static bool is_float(int t) {
    return is_predefined(t, id_float, "FLOAT");
}

// tests if t3 is the cartesian product of t1 and t2
static bool is_prod_of(int t1, int t2, int t3) {
    if(!is_prod(t3))
        return false;
    pair<int,int> p = make_pair(t1, t2);
    map<pair<int,int>, int>::iterator it1 = product_of.find(p);
    if(it1 == product_of.end()) {
        TiXmlElement* elem1;
        TiXmlElement* elem2;
        TiXmlElement* elem3;
        if(!get_type_elem(t1, elem1) || !get_type_elem(t2, elem2)
            || !get_type_elem(t3, elem3))
            return false;
        TiXmlElement* c1;
        TiXmlElement* c2;
        if(elem3 == nullptr) return false;
        c1 = elem3->FirstChildElement();
        if(c1 == nullptr) return false;
        c2 = c1->NextSiblingElement();
        if(c2 == nullptr) return false;
        if(elem1 != nullptr && are_equal(elem1, c1) &&
           elem2 != nullptr && are_equal(elem2, c2)) {
            product_of.insert(make_pair(make_pair(t1, t2), t3));
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return t3 == it1->second;
    }
}

// tests if t2 is the powerset of t1
static bool is_pow_of(int t1, int t2) {
    if(!is_pow(t2))
        return false;
    map<int, int>::iterator it1 = powerset_of.find(t1);
    if(it1 == powerset_of.end()) {
        map<int, TiXmlElement*>::iterator it2 = typeinfos.find(t1);
        if(it2 == typeinfos.end()) {
            cerr << "No type definition for typref " << t1 << ".\n";
            return false;
        }
        TiXmlElement* elem1;
        TiXmlElement* elem2;
        if(!get_type_elem(t1, elem1) || !get_type_elem(t2, elem2))
            return false;
        if(elem1 != nullptr && elem2 != nullptr &&
           are_equal(elem1, elem2->FirstChildElement())) {
            powerset_of.insert(make_pair(t1, t2));
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return t2 == it1->second;
    }
}

// tests if t3 = POW(T1*T2), where t1=POW(T1) and t2=POW(T2)
static bool is_pow_of_prod_of(int t1, int t2, int t3) {
    TiXmlElement* e3 = typeinfos.at(t3);
    TiXmlElement* e4;
    TiXmlElement* e5;
    TiXmlElement* e6;
    if(!is_pow(e3))
        return false;
    e4 = e3->FirstChildElement();
    if(e4 == nullptr)
        return false;
    e5 = e4->FirstChildElement();
    if(e5 == nullptr)
        return false;
    e6 = e5->NextSiblingElement();
    if(e6 == nullptr)
        return false;
    return are_equal(typeinfos.at(t1)->FirstChildElement(), e5) &&
        are_equal(typeinfos.at(t2)->FirstChildElement(), e6);
}

// tests if t3 = POW(POW(T1*T2)),
// where t1=POW(T1) and t2=POW(T2)
static bool is_pow_of_pow_of_prod_of(int t1, int t2, int t3) {
    TiXmlElement* e3 = typeinfos.at(t3);
    TiXmlElement* e4;
    TiXmlElement* e5;
    TiXmlElement* e6;
    TiXmlElement* e7;
    if(!is_pow(e3))
        return false;
    e4 = e3->FirstChildElement();
    // e4 = POW(T1*T2) ?
    if(!is_pow(e4))
        return false;
    e5 = e4->FirstChildElement();
    // e5 = T1*T2 ?
    if(!is_prod(e5))
        return false;
    e6 = e5->FirstChildElement();
    if(e6 == nullptr)
        return false;
    e7 = e6->NextSiblingElement();
    if(e7 == nullptr)
        return false;
    return are_equal(typeinfos.at(t1)->FirstChildElement(), e6) &&
        are_equal(typeinfos.at(t2)->FirstChildElement(), e7);
}

static bool are_equal(TiXmlElement* elem1, TiXmlElement* elem2) {
    if (elem1 == nullptr && elem2 == nullptr)
        return true;
    if (elem1 == nullptr )
        return false;
    if (elem2 == nullptr)
        return false;
    if (strcmp(elem1->Value(), elem2->Value()) != 0)
        return false;
    for(TiXmlAttribute* attr1 = elem1->FirstAttribute();
        attr1 != nullptr;
        attr1 = attr1->Next()) {
        const char* name1 = attr1->Name();
        const char* value1 = attr1->Value();
        const char* value2 = elem2->Attribute(name1);
        if (value2 == nullptr || strcmp(value1, value2) != 0)
            return false;
    }
    for(TiXmlAttribute* attr2 = elem2->FirstAttribute();
        attr2 != nullptr;
        attr2 = attr2->Next()) {
        const char* name2 = attr2->Name();
        const char* value1 = elem1->Attribute(name2);
        if (value1 == nullptr)
            return false;
    }
    TiXmlElement* child1 = elem1->FirstChildElement();
    TiXmlElement* child2 = elem2->FirstChildElement();
    while(child1 != nullptr && child2 != nullptr) {
        if (!are_equal(child1, child2))
            return false;
        child1 = child1->NextSiblingElement();
        child2 = child2->NextSiblingElement();
    }
    return child1 == nullptr && child1 == nullptr;
}
